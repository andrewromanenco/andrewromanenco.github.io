{"version":3,"sources":["MessageOp.js","MessageBroker.js","Node.js","heartbeat/BeatOp.js","DeliverOp.js","heartbeat/IamAliveOp.js","heartbeat/ServerNode.js","heartbeat/CheckTimeoutOp.js","heartbeat/WatcherNode.js","heartbeat/HeartBeatExample.js","PauseOp.js","App.js","reportWebVitals.js","index.js"],"names":["MessageOp","toName","fromName","String","Error","this","to","from","op","constructor","name","node","tickNumber","MessageBroker","nodes","brokenLinks","newNode","forEach","push","blockedPairsList","JSON","parse","Array","isArray","console","log","badElements","el","error","stringify","e","message","blocked","pair","delivered","scheduleOp","role","shuffle","result","hasRole","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","Node","roles","queue","messageBroker","state","registerNode","q","unshift","shift","execute","includes","BeatOp","gotBeatFrom","DeliverOp","messagesToDeliver","msg","sendMessage","IamAliveOp","nextBeatNotBefore","watchers","findByRole","w","beatOp","deliverOp","ServerNode","CheckTimeoutOp","Object","entries","lastSeen","diff","WatcherNode","Initializer","bind","PauseOp","sleep","scheduleOpOnTop","App","props","example","create","tick","sleepTicks","nodeToSleep","handleBrokenLinksChange","handleSleepTicksChange","handleNodeToSleepChange","addSleepToNode","validateBrokenLinks","scheduledTicks","hasScheduledOps","newTick","newNodes","setState","parseInt","event","setBrokenLinks","target","value","controlUI","Button","variant","onClick","TableContainer","Table","aria-label","TableHead","TableRow","TableCell","TableBody","map","item","ind","k","v","TextField","label","onChange","multiline","fullWidth","rows","Select","MenuItem","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"iRAyBeA,G,iBAjBb,WAAYC,EAAQC,GAClB,GAD6B,oBACP,kBAAXD,GAAuBA,aAAkBE,OAClD,MAAM,IAAIC,MAAM,2BAElB,GAAwB,kBAAbF,GAAyBA,aAAoBC,OACtD,MAAM,IAAIC,MAAM,6BAElBC,KAAKC,GAAKL,EACVI,KAAKE,KAAOL,EACZG,KAAKG,GAAKH,KAAKI,YAAYC,K,oDAGrBC,EAAMC,GACZ,MAAM,IAAIR,MAAM,iC,MCmGLS,E,WAjHb,aAAe,oBACbR,KAAKS,MAAQ,GACbT,KAAKU,YAAc,K,yDAMRC,GACXX,KAAKS,MAAMG,SAAQ,SAAAN,GACjB,GAAIA,EAAKD,OAASM,EAAQN,KACxB,MAAM,IAAIN,MAAM,4BAA8BO,EAAKD,SAGvDL,KAAKS,MAAMI,KAAKF,K,4CAUhB,IACE,IAAMG,EAAmBC,KAAKC,MAAMhB,KAAKU,aACzC,IAAKO,MAAMC,QAAQJ,GAEjB,OADAK,QAAQC,IAAI,0CACL,EAET,IAAIC,GAAc,EAOlB,GANAP,EAAiBF,SAAQ,SAAAU,GAClBL,MAAMC,QAAQI,KACjBD,GAAc,EACdF,QAAQI,MAAM,gEAAkER,KAAKS,UAAUF,QAG/FD,EACF,OAAO,EAET,MAAMI,GAEN,OADAN,QAAQC,IAAI,gEACL,EAET,OAAO,I,kCASGM,GACV,KAAMA,aAAmB/B,GACvB,MAAMI,MAAM,wDAA0DgB,KAAKS,UAAUE,IAEvF,IAAMZ,EAAmBC,KAAKC,MAAMhB,KAAKU,aACrCiB,GAAU,EAOd,GANAb,EAAiBF,SAAQ,SAAAgB,IACjBA,EAAK,KAAOF,EAAQzB,IAAM2B,EAAK,KAAOF,EAAQxB,MAC5C0B,EAAK,KAAOF,EAAQzB,IAAM2B,EAAK,KAAOF,EAAQxB,QAChDyB,GAAU,MAGdA,EACFR,QAAQC,IAAI,6CADd,CAIA,IAAIS,GAAY,EAOhB,GANA7B,KAAKS,MAAMG,SAAQ,SAAAN,GACbA,EAAKD,OAASqB,EAAQzB,KACxBK,EAAKwB,WAAWJ,GAChBG,GAAY,OAGXA,EACH,MAAM,IAAI9B,MAAM,8BAAgCgB,KAAKS,UAAUE,O,iCAOxDK,EAAMC,GACf,IAAMC,EAAS,GAOf,GANAjC,KAAKS,MAAMG,SAAQ,SAAAN,GACbA,EAAK4B,QAAQH,IACfE,EAAOpB,KAAKP,MAIZ0B,EAEF,IADA,IAAkCG,EAAgBC,EAA9CC,EAAeJ,EAAOK,OACnB,IAAMD,GACXD,EAAcG,KAAKC,MAAMD,KAAKE,SAAWJ,GAEzCF,EAAiBF,EADjBI,GAAgB,GAEhBJ,EAAOI,GAAgBJ,EAAOG,GAC9BH,EAAOG,GAAeD,EAG1B,OAAOF,I,qCAMMvB,GACbV,KAAKU,YAAcA,M,KCnDRgC,E,WA7Db,WAAYrC,EAAMsC,GAAQ,oBACxB3C,KAAKK,KAAOA,EACRsC,EACE1B,MAAMC,QAAQyB,GAChB3C,KAAK2C,MAAQA,EAEb3C,KAAK2C,MAAQ,CAACA,GAGhB3C,KAAK2C,MAAQ,GAEf3C,KAAK4C,MAAQ,GACb5C,KAAK6C,cAAgB,KACrB7C,KAAK8C,MAAQ,G,iDAIVD,GAGH,OAFA7C,KAAK6C,cAAgBA,EACrBA,EAAcE,aAAa/C,MACpBA,O,iCAKEG,GACT,IAAM6C,EAAC,YAAOhD,KAAK4C,OACnBI,EAAEnC,KAAKV,GACPH,KAAK4C,MAAQI,I,sCAIC7C,GACd,IAAM6C,EAAC,YAAOhD,KAAK4C,OACnBI,EAAEC,QAAQ9C,GACVH,KAAK4C,MAAQI,I,2BAIVzC,GACH,IAAKP,KAAK6C,cACR,MAAM,IAAI9C,MAAM,iCAAmCC,KAAKK,MAEhC,IAAtBL,KAAK4C,MAAMN,QAGJtC,KAAK4C,MAAMM,QACnBC,QAAQnD,KAAMO,K,wCAKjB,OAAQP,KAAK4C,MAAMN,OAAS,I,8BAItBP,GACN,OAAO/B,KAAK2C,MAAMS,SAASrB,O,KClDhBsB,E,sKALL/C,EAAMC,GACZD,EAAKgD,YAAYtD,KAAKE,KAAMK,O,GAFXZ,GC0BN4D,E,WApBb,WAAYC,GACV,GAD8B,qBACzBvC,MAAMC,QAAQsC,GACjB,MAAM,IAAIzD,MAAM,kCAElByD,EAAkB5C,SAAQ,SAAA6C,GACxB,KAAMA,aAAe9D,GACnB,MAAM,IAAII,MAAM,yCAA2CgB,KAAKS,UAAUiC,OAG9EzD,KAAKwD,kBAAoBA,E,oDAGnBlD,EAAMC,GACZP,KAAKwD,kBAAkB5C,SAAQ,SAAA6C,GAC7BtC,QAAQC,IAAR,eAAoBqC,EAAItD,GAAxB,eAAiCsD,EAAIxD,KACrCK,EAAKuC,cAAca,YAAYD,U,KCItBE,E,WArBb,aAAe,oBACb3D,KAAKG,GAAKH,KAAKI,YAAYC,K,oDAGrBC,EAAMC,GACZ,GAAIA,GAAcD,EAAKwC,MAAMc,kBAAmB,CAC9CtD,EAAKwC,MAAMc,mBAAqB,GAChC,IAAMC,EAAWvD,EAAKuC,cAAciB,WAAW,WAC/C3C,QAAQC,IAAR,oCAAyCyC,EAASvB,OAAlD,cACAuB,EAASjD,SAAQ,SAAAmD,GACf,IAAMC,EAAS,IAAIX,EAAOU,EAAE1D,KAAMC,EAAKD,MACjC4D,EAAY,IAAIV,EAAU,CAACS,IACjC1D,EAAKwB,WAAWmC,WAGlB9C,QAAQC,IAAI,oCAEdd,EAAKwB,WAAW9B,U,KCTLkE,E,kDAVb,WAAY7D,GAAO,IAAD,8BAChB,cAAMA,IACDuC,MAAQ,CAAC,IAAIe,GAClB,EAAKb,MAAQ,CACXc,kBAAmBrB,KAAKC,MAAMD,KAAKE,SAAWF,KAAKC,MAAM,KAJ3C,E,UADKE,GCkBVyB,E,WAnBb,aAAe,oBACbnE,KAAKG,GAAKH,KAAKI,YAAYC,K,oDAMrBC,EAAMC,GACZ6D,OAAOC,QAAQ/D,EAAKwC,OAAOlC,SAAQ,YAAgC,IAAD,mBAA7BP,EAA6B,2BAAvBiE,EAAuB,KAC1DC,GAD0D,KACnDhE,EAAa+D,GACtBC,EAAO,KACTpD,QAAQC,IAAR,iBAAsBf,EAAtB,oCAAsDkE,EAAtD,YACAjE,EAAKwC,MAAMzC,GAAM,GAAK,cAG1BC,EAAKwB,WAAW9B,U,KCCLwE,E,kDAZb,WAAYnE,GAAO,IAAD,8BAChB,cAAMA,IACDsC,MAAQ,CAAC,WACd,EAAKC,MAAQ,CAAC,IAAIuB,GAHF,E,wDAMN9D,EAAME,GAChBY,QAAQC,IAAI,wBAA0Bf,GACtCL,KAAK8C,MAAMzC,GAAQ,CAACE,EAAY,a,GATVmC,GCuBX+B,E,+FAvBN5B,GACL,IAAIqB,EAAW,YAAYQ,KAAK7B,GAChC,IAAIqB,EAAW,YAAYQ,KAAK7B,GAChC,IAAIqB,EAAW,YAAYQ,KAAK7B,GAEhC,IAAI2B,EAAY,aAAaE,KAAK7B,GAClC,IAAI2B,EAAY,aAAaE,KAAK7B,GAClC,IAAI2B,EAAY,aAAaE,KAAK7B,K,kCAIlC,OACE,gCACE,4CACA,uHACA,gLAEA,qG,+FCJO8B,E,WAfb,WAAYC,GAAQ,oBAClB5E,KAAK4E,MAAQA,E,oDAGPtE,EAAMC,GACRP,KAAK4E,MAAQ,GACfzD,QAAQC,IAAI,uBAAyBpB,KAAK4E,MAAQ,IAClDtE,EAAKuE,gBAAgB,IAAIF,EAAQ3E,KAAK4E,MAAQ,KAE9CzD,QAAQC,IAAI,oB,KC6IH0D,E,kDAvIb,WAAYC,GAAQ,IAAD,EAKjB,GALiB,qBACjB,cAAMA,IACDlC,cAAgB,IAAIrC,EACzB,EAAKwE,QAAU,IAAIP,EACnB,EAAKO,QAAQC,OAAO,EAAKpC,eACe,IAApC,EAAKA,cAAcpC,MAAM6B,OAC3B,MAAM,IAAIvC,MAAM,yBAND,OAQjB,EAAK+C,MAAQ,CACXrC,MAAM,YAAK,EAAKoC,cAAcpC,OAC9ByE,KAAM,EACNxE,YAAa,KACbyE,WAAY,IACZC,YAAa,EAAKvC,cAAcpC,MAAM,GAAGJ,MAE3C,EAAK6E,KAAO,EAAKA,KAAKR,KAAV,gBACZ,EAAKW,wBAA0B,EAAKA,wBAAwBX,KAA7B,gBAC/B,EAAKY,uBAAyB,EAAKA,uBAAuBZ,KAA5B,gBAC9B,EAAKa,wBAA0B,EAAKA,wBAAwBb,KAA7B,gBAC/B,EAAKc,eAAiB,EAAKA,eAAed,KAApB,gBAnBL,E,mDA0BX,IAAD,OACL,GAAK1E,KAAK6C,cAAc4C,sBAAxB,CAGAtE,QAAQC,IAAI,mBAAqBpB,KAAK8C,MAAMoC,MAC5C,IAAMQ,EAAiB,GACvB1F,KAAK8C,MAAMrC,MAAMG,SAAQ,SAAAN,GACnBA,EAAKqF,mBACPD,EAAe7E,KAAKP,MAGxBoF,EAAe9E,SAAQ,SAAAN,GACrBa,QAAQC,IAAI,WAAad,EAAKD,MAC9BC,EAAK4E,KAAK,EAAKpC,MAAMoC,SAEvB/D,QAAQC,IAAI,kBAAoBpB,KAAK8C,MAAMoC,MAC3C/D,QAAQC,IAAI,4BACZ,IAAMwE,EAAU5F,KAAK8C,MAAMoC,KAAO,EAC5BW,EAAQ,YAAO7F,KAAK6C,cAAcpC,OACxCT,KAAK8F,SAAS,CACZZ,KAAMU,EACNnF,MAAOoF,O,uCAOO,IAAD,OACf7F,KAAK8C,MAAMrC,MAAMG,SAAQ,SAAAN,GACnBA,EAAKD,OAAS,EAAKyC,MAAMsC,cAC3BjE,QAAQC,IAAI,kBAAoBd,EAAKD,MACrCC,EAAKuE,gBAAgB,IAAIF,EAAQoB,SAAS,EAAKjD,MAAMqC,kBAGzDnF,KAAK8F,SAAS,CAACrF,MAAM,YAAKT,KAAK8C,MAAMrC,W,8CAGfuF,GACtBhG,KAAK6C,cAAcoD,eAAeD,EAAME,OAAOC,OAC/CnG,KAAK8F,SAAS,CAACpF,YAAasF,EAAME,OAAOC,U,6CAGpBH,GACrBhG,KAAK8F,SAAS,CAACX,WAAYa,EAAME,OAAOC,U,8CAGlBH,GACtBhG,KAAK8F,SAAS,CAACV,YAAaY,EAAME,OAAOC,U,+BAIzC,OACE,gCACGnG,KAAKgF,QAAQoB,YACd,eAACC,EAAA,EAAD,CAAQC,QAAQ,YAAYC,QAASvG,KAAKkF,KAA1C,mBAAuDlF,KAAK8C,MAAMoC,KAAlE,OAAiF,uBACjF,cAACsB,EAAA,EAAD,UACE,eAACC,EAAA,EAAD,CAAOC,aAAW,eAAlB,UACE,cAACC,EAAA,EAAD,UACE,eAACC,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,wBACA,cAACA,EAAA,EAAD,6BACA,cAACA,EAAA,EAAD,yBAGJ,cAACC,EAAA,EAAD,UACG9G,KAAK8C,MAAMrC,MAAMsG,KAAI,SAACzG,GAAD,OACpB,eAACsG,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,UACGvG,EAAKD,OAER,cAACwG,EAAA,EAAD,UACGvG,EAAKsC,MAAMmE,KAAI,SAACC,EAAMC,GAAP,OAAgB,8BAAsClG,KAAKS,UAAUwF,IAA3C1G,EAAKD,KAAO2G,EAAK7G,GAAK8G,QAElE,cAACJ,EAAA,EAAD,UACCzC,OAAOC,QAAQ/D,EAAKwC,OAAOiE,KAAI,mCAAEG,EAAF,KAAIC,EAAJ,YAC9B,8BAAyB,gCAAMD,EAAN,KAAWnG,KAAKS,UAAU2F,EAAG,KAAM,OAAlD7G,EAAKD,KAAO6G,UATX5G,EAAKD,gBAiB5B,cAAC+G,EAAA,EAAD,CACAC,MAAM,iHACNlB,MAAOnG,KAAK8C,MAAMpC,YAClB4G,SAAUtH,KAAKqF,wBACfkC,WAAW,EACXC,WAAW,EACXC,KAAK,OAAO,uBACZ,cAACL,EAAA,EAAD,CACAC,MAAM,wBACNlB,MAAOnG,KAAK8C,MAAMqC,WAClBmC,SAAUtH,KAAKsF,uBACfiC,WAAW,EACXC,WAAW,EACXC,KAAK,MACL,cAACC,EAAA,EAAD,CAAQvB,MAAOnG,KAAK8C,MAAMsC,YAAakC,SAAUtH,KAAKuF,wBAAtD,SACGvF,KAAK8C,MAAMrC,MAAMsG,KAAI,SAAAzG,GAAI,OACxB,cAACqH,EAAA,EAAD,CAA0BxB,MAAO7F,EAAKD,KAAtC,SAA6CC,EAAKD,MAAnCC,EAAKD,WAGxB,eAACgG,EAAA,EAAD,CAAQC,QAAQ,YAAYC,QAASvG,KAAKwF,eAA1C,0BAAwExF,KAAK8C,MAAMsC,eAAqB,8B,GAlI9FwC,IAAMC,WCRTC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.6cce2809.chunk.js","sourcesContent":["/*\nEvery message is actually an operation to be executed by node on tick.\nSome operations are local, e.g. sleep; others are messages being\nsend via the message broker.\n\nThis is the parent for all sendable messages.\n*/\nclass MessageOp {\n  constructor(toName, fromName) {\n    if (typeof toName !== 'string' && toName instanceof String) {\n      throw new Error(\"toName must be a string\");\n    }\n    if (typeof fromName !== 'string' && fromName instanceof String) {\n      throw new Error(\"fromName must be a string\");\n    }\n    this.to = toName;\n    this.from = fromName;\n    this.op = this.constructor.name;\n  }\n\n  execute(node, tickNumber) {\n    throw new Error(\"Must override this method\");\n  }\n}\n\nexport default MessageOp;\n","import MessageOp from './MessageOp';\n\n/*\nMain message bus - simulated network.\nAllows connections b/n all nodes. Supports blocking channels b/n nodes.\n*/\nclass MessageBroker {\n  constructor() {\n    this.nodes = [];\n    this.brokenLinks = \"[]\";\n  }\n\n  /*\n  Registered node is discoverable by name and role.\n  */\n  registerNode(newNode) {\n    this.nodes.forEach(node => {\n      if (node.name === newNode.name) {\n        throw new Error('Name already registered: ' + node.name);\n      }\n    });\n    this.nodes.push(newNode);\n  }\n\n  /*\n  Broken links is a list of pairs of node names to block communication channel.\n  This is used to simulate network partitioning.\n  The config is supplied by user input and this methiod checks if the input\n  is valid.\n  */\n  validateBrokenLinks() {\n    try {\n      const blockedPairsList = JSON.parse(this.brokenLinks);\n      if (!Array.isArray(blockedPairsList)) {\n        console.log(\"Broken list must be an array of pairs\");\n        return false;\n      }\n      var badElements = false;\n      blockedPairsList.forEach(el => {\n        if (!Array.isArray(el)) {\n          badElements = true;\n          console.error('Elements of block list must by lists like [\"A\", \"B\"] but got ' + JSON.stringify(el));\n        }\n      });\n      if (badElements) {\n        return false;\n      }\n    } catch(e) {\n      console.log(\"Bad json for broken list, must be json, e.g. '[]' for empty\");\n      return false;\n    };\n    return true;\n  }\n\n  /*\n  Yes, sendMessage method does send a message\n  Message us delivered to target node's execution queue.\n  Message is plain object and must have \"to\", \"from\" and \"op\".\n  Messgae is deliverd unless the channel b/n nodes is offline.\n  */\n  sendMessage(message) {\n    if (!(message instanceof MessageOp)) {\n      throw Error('The message to send is not an instance of MessageOp: ' + JSON.stringify(message));\n    }\n    const blockedPairsList = JSON.parse(this.brokenLinks);\n    var blocked = false;\n    blockedPairsList.forEach(pair => {\n      if (((pair[0] === message.to)&&(pair[1] === message.from))\n          ||((pair[1] === message.to)&&(pair[0] === message.from))) {\n            blocked = true;\n          }\n    });\n    if (blocked) {\n      console.log(\"Message is dropped due to block rule.\");\n      return;\n    }\n    var delivered = false;\n    this.nodes.forEach(node => {\n      if (node.name === message.to) {\n        node.scheduleOp(message);\n        delivered = true;\n      }\n    });\n    if (!delivered) {\n      throw new Error('Failed to deliver message: ' + JSON.stringify(message));\n    }\n  }\n\n  /*\n  Finds all registered nodes with given role.\n  */\n  findByRole(role, shuffle) {\n    const result = [];\n    this.nodes.forEach(node => {\n      if (node.hasRole(role)) {\n        result.push(node);\n      }\n    });\n\n    if (shuffle) {\n      var currentIndex = result.length, temporaryValue, randomIndex;\n      while (0 !== currentIndex) {\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n        temporaryValue = result[currentIndex];\n        result[currentIndex] = result[randomIndex];\n        result[randomIndex] = temporaryValue;\n      }\n    }\n    return result;\n  }\n\n  /*\n  Setter for channel blocking (to simulate network partition).\n  */\n  setBrokenLinks(brokenLinks) {\n    this.brokenLinks = brokenLinks;\n  }\n}\n\nexport default MessageBroker;\n","// Base class for all nodes\nclass Node {\n  // Each node has a name and optional roles.\n  // Roles are used for node selection.\n  constructor(name, roles) {\n    this.name = name;\n    if (roles) {\n      if (Array.isArray(roles)) {\n        this.roles = roles;\n      } else {\n        this.roles = [roles];\n      }\n    } else {\n      this.roles = [];\n    }\n    this.queue = [];\n    this.messageBroker = null;\n    this.state = {};\n  }\n\n  // Registers the node with the message bus\n  bind(messageBroker) {\n    this.messageBroker = messageBroker;\n    messageBroker.registerNode(this);\n    return this;\n  }\n\n  // Add an operation into the execution queue. Add to tail.\n  // Each tick one operation is executed.\n  scheduleOp(op) {\n    const q = [...this.queue];\n    q.push(op);\n    this.queue = q;\n  }\n\n  // Adds operations as the next to be executed.\n  scheduleOpOnTop(op) {\n    const q = [...this.queue];\n    q.unshift(op);\n    this.queue = q;\n  }\n\n  // Called every tick and executed next operation from the exec. queue.\n  tick(tickNumber) {\n    if (!this.messageBroker) {\n      throw new Error(\"Message broker is not set for \" + this.name);\n    }\n    if (this.queue.length === 0) {\n      return;\n    }\n    const op = this.queue.shift();\n    op.execute(this, tickNumber);\n  }\n\n  // Check if this node has operations to excute.\n  hasScheduledOps() {\n    return (this.queue.length > 0);\n  }\n\n  // Check if the node has a specific role.\n  hasRole(role) {\n    return this.roles.includes(role);\n  }\n}\n\nexport default Node;\n","import MessageOp from '../MessageOp';\n\n/*\nHeart beat is sent by servers to watchers.\n*/\nclass BeatOp extends MessageOp {\n  execute(node, tickNumber) {\n    node.gotBeatFrom(this.from, tickNumber);\n  }\n}\n\nexport default BeatOp;\n","import MessageOp from './MessageOp';\n\n/*\nWhen a node wants to send a broadcast, there are two options: either send\nall messages at once or send them one by one. The difference is how \"fast\"\nthe sender is.\nThis class is a helper to send messages one by one, consuming a tick for each.\nThe node uses this class to \"schedule\" messages, they are added to the queue\nand executed as any other command.\n*/\nclass DeliverOp {\n  constructor(messagesToDeliver) {\n    if (!Array.isArray(messagesToDeliver)) {\n      throw new Error(\"The parameter has to be a list\");\n    }\n    messagesToDeliver.forEach(msg => {\n      if (!(msg instanceof MessageOp)) {\n        throw new Error(\"Can only deliver MessageOp instances: \" + JSON.stringify(msg));\n      }\n    });\n    this.messagesToDeliver = messagesToDeliver;\n  }\n\n  execute(node, tickNumber) {\n    this.messagesToDeliver.forEach(msg => {\n      console.log(`Sent ${msg.op} to ${msg.to}`);\n      node.messageBroker.sendMessage(msg);\n    });\n  }\n}\n\nexport default DeliverOp;\n","import BeatOp from './BeatOp';\nimport DeliverOp from '../DeliverOp';\n\n/*\nWhen called, the operation sends heartbeat to every watcher.\nThe operation reschedules itself.\nHeartbeat is sent every 10 ticks.\n*/\nclass IamAliveOp {\n  constructor() {\n    this.op = this.constructor.name;\n  }\n\n  execute(node, tickNumber) {\n    if (tickNumber >= node.state.nextBeatNotBefore) {\n      node.state.nextBeatNotBefore += 10;\n      const watchers = node.messageBroker.findByRole('watcher');\n      console.log(`Schedule beat delivery to ${watchers.length} watchers`);\n      watchers.forEach(w => {\n        const beatOp = new BeatOp(w.name, node.name);\n        const deliverOp = new DeliverOp([beatOp]);\n        node.scheduleOp(deliverOp);\n      });\n    } else {\n      console.log(\"Alive, but not the beat time yet\");\n    }\n    node.scheduleOp(this);\n  }\n}\n\nexport default IamAliveOp;\n","import Node from '../Node';\nimport IamAliveOp from './IamAliveOp';\n\n/*\nServer node. Keeps calling IamAliveOp to send hearbeat every 10 ticks.\n*/\nclass ServerNode extends Node {\n  constructor(name) {\n    super(name);\n    this.queue = [new IamAliveOp()];\n    this.state = {\n      nextBeatNotBefore: Math.floor(Math.random() * Math.floor(5))\n    }\n  }\n\n}\n\nexport default ServerNode;\n","/*\nWhen called the operation checks if there are stale servers.\nAfter call the operations adds itself back to the queue to be called later.\n*/\nclass CheckTimeoutOp {\n  constructor() {\n    this.op = this.constructor.name;\n  }\n\n  /*\n  Go over servers seens so far and mark them Offline in no hearbeat for 15 ticks.\n  */\n  execute(node, tickNumber) {\n    Object.entries(node.state).forEach(([name,[lastSeen, status]]) => {\n      const diff = tickNumber - lastSeen;\n      if (diff > 15) {\n        console.log(`Server ${name} is OFFLINE. No beat for ${diff} ticks.`);\n        node.state[name][1] = 'OFFLINE';\n      }\n    });\n    node.scheduleOp(this);\n  }\n}\n\nexport default CheckTimeoutOp;\n","import Node from '../Node';\nimport CheckTimeoutOp from './CheckTimeoutOp';\n\n/*\nInitally the watcher knows nothing about any servers.\nAs soon as first beat arrives, the sender get tracked.\nA sender is alive if there is a beat in last 10 ticks.\n*/\nclass WatcherNode extends Node {\n  constructor(name) {\n    super(name);\n    this.roles = ['watcher'];\n    this.queue = [new CheckTimeoutOp()];\n  }\n\n  gotBeatFrom(name, tickNumber) {\n    console.log(\"Recevied a beat from \" + name);\n    this.state[name] = [tickNumber, 'ALIVE'];\n  }\n}\n\nexport default WatcherNode;\n","import ServerNode from './ServerNode';\nimport WatcherNode from './WatcherNode';\n\n/*\nHeartbeat example. Three servers and three watchers. Watchers wait for\nthe hearbeat and if no detected for 15 ticks, then mark servers as Offline.\n*/\nclass Initializer {\n  create(messageBroker) {\n    new ServerNode('Server-A').bind(messageBroker);\n    new ServerNode('Server-B').bind(messageBroker);\n    new ServerNode('Server-C').bind(messageBroker);\n\n    new WatcherNode('Watcher-X').bind(messageBroker);\n    new WatcherNode('Watcher-Y').bind(messageBroker);\n    new WatcherNode('Watcher-Z').bind(messageBroker);\n  }\n\n  controlUI() {\n    return (\n      <div>\n        <h1>Heart beat</h1>\n        <div>Open debug console to see log message. Keep clicking Tick for step-by-step progress.</div>\n        <div>Three nodes send heart beats to three watchers. Use channel block feature or add sleep to\n        ServerNodes to see how watchers change their state.</div>\n        <div>Watchers mark servers Offline if no heartbeat for 15 ticks.</div>\n      </div>\n    );\n  }\n}\n\nexport default Initializer;\n","/*\nNon sendable operation, which sleeps for the given number of ticks.\nThis operation may simulate a node being busy. The node will still be\nable to receive messages, but win't process them.\n*/\nclass PauseOp {\n  constructor(sleep) {\n    this.sleep = sleep;\n  }\n\n  execute(node, tickNumber) {\n    if (this.sleep > 1) {\n      console.log(\"Still sleeping for \" + (this.sleep - 1));\n      node.scheduleOpOnTop(new PauseOp(this.sleep - 1));\n    } else {\n      console.log(\"Slept enough\");\n    }\n  }\n\n}\n\nexport default PauseOp;\n","import './App.css';\nimport MessageBroker from './MessageBroker';\nimport Initializer from './heartbeat/HeartBeatExample'\n//import Initializer from './ping/PingExample'\n//import Initializer from './basic-paxos/BasicPaxosExample'\n//import Initializer from './multi-paxos/MultiPaxosExample'\nimport React from 'react';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\nimport Button from '@material-ui/core/Button';\nimport TextField from '@material-ui/core/TextField';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport Select from '@material-ui/core/Select';\nimport PauseOp from './PauseOp';\n\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.messageBroker = new MessageBroker();\n    this.example = new Initializer();\n    this.example.create(this.messageBroker);\n    if (this.messageBroker.nodes.length === 0) {\n      throw new Error(\"No nodes to work with\");\n    }\n    this.state = {\n      nodes: [...this.messageBroker.nodes],\n      tick: 1,\n      brokenLinks: \"[]\",\n      sleepTicks: \"0\",\n      nodeToSleep: this.messageBroker.nodes[0].name\n    }\n    this.tick = this.tick.bind(this);\n    this.handleBrokenLinksChange = this.handleBrokenLinksChange.bind(this);\n    this.handleSleepTicksChange = this.handleSleepTicksChange.bind(this);\n    this.handleNodeToSleepChange = this.handleNodeToSleepChange.bind(this);\n    this.addSleepToNode = this.addSleepToNode.bind(this);\n  }\n\n  /*\n  The \"main\" method. On exec it goes over all nodes and executes one\n  operation from nodes' queues.\n  */\n  tick() {\n    if (!this.messageBroker.validateBrokenLinks()) {\n      return;\n    }\n    console.log(\"Start with tick \" + this.state.tick);\n    const scheduledTicks = [];\n    this.state.nodes.forEach(node => {\n      if (node.hasScheduledOps()) {\n        scheduledTicks.push(node);\n      }\n    });\n    scheduledTicks.forEach(node => {\n      console.log(\"Tick on \" + node.name);\n      node.tick(this.state.tick);\n    });\n    console.log(\"Done with tick \" + this.state.tick);\n    console.log(\"------------------------\");\n    const newTick = this.state.tick + 1;\n    const newNodes = [...this.messageBroker.nodes];\n    this.setState({\n      tick: newTick,\n      nodes: newNodes,\n    });\n  }\n\n  /*\n  Simulates a node being \"frozen\" for a bit.\n  */\n  addSleepToNode() {\n    this.state.nodes.forEach(node => {\n      if (node.name === this.state.nodeToSleep) {\n        console.log(\"Added sleep to \" + node.name);\n        node.scheduleOpOnTop(new PauseOp(parseInt(this.state.sleepTicks)));\n      }\n    });\n    this.setState({nodes: [...this.state.nodes]});\n  }\n\n  handleBrokenLinksChange(event) {\n    this.messageBroker.setBrokenLinks(event.target.value);\n    this.setState({brokenLinks: event.target.value});\n  }\n\n  handleSleepTicksChange(event) {\n    this.setState({sleepTicks: event.target.value});\n  }\n\n  handleNodeToSleepChange(event) {\n    this.setState({nodeToSleep: event.target.value});\n  }\n\n  render() {\n    return (\n      <div>\n        {this.example.controlUI()}\n        <Button variant=\"contained\" onClick={this.tick}>Tick ({this.state.tick})</Button><br/>\n        <TableContainer>\n          <Table aria-label=\"simple table\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Node name</TableCell>\n                <TableCell>Incoming queue</TableCell>\n                <TableCell>State</TableCell>\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {this.state.nodes.map((node) => (\n                <TableRow key={node.name}>\n                  <TableCell>\n                    {node.name}\n                  </TableCell>\n                  <TableCell>\n                    {node.queue.map((item, ind) => (<div key={node.name + item.op + ind}>{JSON.stringify(item)}</div>))}\n                  </TableCell>\n                  <TableCell>\n                  {Object.entries(node.state).map(([k,v]) => (\n                    <div key={node.name + k}><pre>{k}: {JSON.stringify(v, null, 2)}</pre></div>\n                  ))}\n                  </TableCell>\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <TextField\n        label='Json list of pairs of broken list. E.g. [[\"A\", \"B\"], [\"A\", \"C\"]] messages b/n A<->B and A<->C will be dropped.'\n        value={this.state.brokenLinks}\n        onChange={this.handleBrokenLinksChange}\n        multiline={true}\n        fullWidth={true}\n        rows=\"10\" /><br/>\n        <TextField\n        label='Sleep length in ticks'\n        value={this.state.sleepTicks}\n        onChange={this.handleSleepTicksChange}\n        multiline={false}\n        fullWidth={false}\n        rows=\"1\" />\n        <Select value={this.state.nodeToSleep} onChange={this.handleNodeToSleepChange}>\n          {this.state.nodes.map(node => (\n            <MenuItem key={node.name} value={node.name}>{node.name}</MenuItem>\n          ))}\n        </Select>\n        <Button variant=\"contained\" onClick={this.addSleepToNode}>Add sleep to {this.state.nodeToSleep}</Button><br/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}