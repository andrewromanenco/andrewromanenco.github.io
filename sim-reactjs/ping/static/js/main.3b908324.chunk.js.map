{"version":3,"sources":["MessageOp.js","MessageBroker.js","ping/PingNode.js","Node.js","ping/PingReplyOp.js","ping/IncomingPingOp.js","Timeout.js","ping/InitiatePingOp.js","ping/PingExample.js","PauseOp.js","App.js","reportWebVitals.js","index.js"],"names":["MessageOp","toName","fromName","String","Error","this","to","from","op","constructor","name","node","tickNumber","MessageBroker","nodes","brokenLinks","newNode","forEach","push","blockedPairsList","JSON","parse","Array","isArray","console","log","badElements","el","error","stringify","e","message","blocked","pair","delivered","scheduleOp","role","shuffle","result","hasRole","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","PingNode","state","gotReply","roles","queue","messageBroker","registerNode","q","unshift","shift","execute","includes","PingReplyOp","replyReceived","IncomingPingOp","sendMessage","Timeout","tickToWait","waitConditionFn","timeoutFn","label","InitiatePingOp","timeout","timedOut","Initializer","nodeA","nodeB","bind","PauseOp","sleep","scheduleOpOnTop","App","props","example","create","tick","sleepTicks","nodeToSleep","handleBrokenLinksChange","handleSleepTicksChange","handleNodeToSleepChange","addSleepToNode","validateBrokenLinks","scheduledTicks","hasScheduledOps","newTick","newNodes","setState","parseInt","event","setBrokenLinks","target","value","controlUI","Button","variant","onClick","TableContainer","Table","aria-label","TableHead","TableRow","TableCell","TableBody","map","item","ind","Object","entries","k","v","TextField","onChange","multiline","fullWidth","rows","Select","MenuItem","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3b908324.chunk.js","sourcesContent":["/*\nEvery message is actually an operation to be executed by node on tick.\nSome operations are local, e.g. sleep; others are messages being\nsend via the message broker.\n\nThis is the parent for all sendable messages.\n*/\nclass MessageOp {\n  constructor(toName, fromName) {\n    if (typeof toName !== 'string' && toName instanceof String) {\n      throw new Error(\"toName must be a string\");\n    }\n    if (typeof fromName !== 'string' && fromName instanceof String) {\n      throw new Error(\"fromName must be a string\");\n    }\n    this.to = toName;\n    this.from = fromName;\n    this.op = this.constructor.name;\n  }\n\n  execute(node, tickNumber) {\n    throw new Error(\"Must override this method\");\n  }\n}\n\nexport default MessageOp;\n","import MessageOp from './MessageOp';\n\n/*\nMain message bus - simulated network.\nAllows connections b/n all nodes. Supports blocking channels b/n nodes.\n*/\nclass MessageBroker {\n  constructor() {\n    this.nodes = [];\n    this.brokenLinks = \"[]\";\n  }\n\n  /*\n  Registered node is discoverable by name and role.\n  */\n  registerNode(newNode) {\n    this.nodes.forEach(node => {\n      if (node.name === newNode.name) {\n        throw new Error('Name already registered: ' + node.name);\n      }\n    });\n    this.nodes.push(newNode);\n  }\n\n  /*\n  Broken links is a list of pairs of node names to block communication channel.\n  This is used to simulate network partitioning.\n  The config is supplied by user input and this methiod checks if the input\n  is valid.\n  */\n  validateBrokenLinks() {\n    try {\n      const blockedPairsList = JSON.parse(this.brokenLinks);\n      if (!Array.isArray(blockedPairsList)) {\n        console.log(\"Broken list must be an array of pairs\");\n        return false;\n      }\n      var badElements = false;\n      blockedPairsList.forEach(el => {\n        if (!Array.isArray(el)) {\n          badElements = true;\n          console.error('Elements of block list must by lists like [\"A\", \"B\"] but got ' + JSON.stringify(el));\n        }\n      });\n      if (badElements) {\n        return false;\n      }\n    } catch(e) {\n      console.log(\"Bad json for broken list, must be json, e.g. '[]' for empty\");\n      return false;\n    };\n    return true;\n  }\n\n  /*\n  Yes, sendMessage method does send a message\n  Message us delivered to target node's execution queue.\n  Message is plain object and must have \"to\", \"from\" and \"op\".\n  Messgae is deliverd unless the channel b/n nodes is offline.\n  */\n  sendMessage(message) {\n    if (!(message instanceof MessageOp)) {\n      throw Error('The message to send is not an instance of MessageOp: ' + JSON.stringify(message));\n    }\n    const blockedPairsList = JSON.parse(this.brokenLinks);\n    var blocked = false;\n    blockedPairsList.forEach(pair => {\n      if (((pair[0] === message.to)&&(pair[1] === message.from))\n          ||((pair[1] === message.to)&&(pair[0] === message.from))) {\n            blocked = true;\n          }\n    });\n    if (blocked) {\n      console.log(\"Message is dropped due to block rule.\");\n      return;\n    }\n    var delivered = false;\n    this.nodes.forEach(node => {\n      if (node.name === message.to) {\n        node.scheduleOp(message);\n        delivered = true;\n      }\n    });\n    if (!delivered) {\n      throw new Error('Failed to deliver message: ' + JSON.stringify(message));\n    }\n  }\n\n  /*\n  Finds all registered nodes with given role.\n  */\n  findByRole(role, shuffle) {\n    const result = [];\n    this.nodes.forEach(node => {\n      if (node.hasRole(role)) {\n        result.push(node);\n      }\n    });\n\n    if (shuffle) {\n      var currentIndex = result.length, temporaryValue, randomIndex;\n      while (0 !== currentIndex) {\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n        temporaryValue = result[currentIndex];\n        result[currentIndex] = result[randomIndex];\n        result[randomIndex] = temporaryValue;\n      }\n    }\n    return result;\n  }\n\n  /*\n  Setter for channel blocking (to simulate network partition).\n  */\n  setBrokenLinks(brokenLinks) {\n    this.brokenLinks = brokenLinks;\n  }\n}\n\nexport default MessageBroker;\n","import Node from '../Node';\n\n/*\nNode to execute ping request/response.\n*/\nclass PingNode extends Node {\n  /*\n  Is called when PingReplyOp is executed.\n  */\n  replyReceived() {\n    this.state.gotReply = true;\n  }\n}\n\nexport default PingNode;\n","// Base class for all nodes\nclass Node {\n  // Each node has a name and optional roles.\n  // Roles are used for node selection.\n  constructor(name, roles) {\n    this.name = name;\n    if (roles) {\n      if (Array.isArray(roles)) {\n        this.roles = roles;\n      } else {\n        this.roles = [roles];\n      }\n    } else {\n      this.roles = [];\n    }\n    this.queue = [];\n    this.messageBroker = null;\n    this.state = {};\n  }\n\n  // Registers the node with the message bus\n  bind(messageBroker) {\n    this.messageBroker = messageBroker;\n    messageBroker.registerNode(this);\n    return this;\n  }\n\n  // Add an operation into the execution queue. Add to tail.\n  // Each tick one operation is executed.\n  scheduleOp(op) {\n    const q = [...this.queue];\n    q.push(op);\n    this.queue = q;\n  }\n\n  // Adds operations as the next to be executed.\n  scheduleOpOnTop(op) {\n    const q = [...this.queue];\n    q.unshift(op);\n    this.queue = q;\n  }\n\n  // Called every tick and executed next operation from the exec. queue.\n  tick(tickNumber) {\n    if (!this.messageBroker) {\n      throw new Error(\"Message broker is not set for \" + this.name);\n    }\n    if (this.queue.length === 0) {\n      return;\n    }\n    const op = this.queue.shift();\n    op.execute(this, tickNumber);\n  }\n\n  // Check if this node has operations to excute.\n  hasScheduledOps() {\n    return (this.queue.length > 0);\n  }\n\n  // Check if the node has a specific role.\n  hasRole(role) {\n    return this.roles.includes(role);\n  }\n}\n\nexport default Node;\n","import MessageOp from '../MessageOp';\n\n/*\nPing reply opeation.\n*/\nclass PingReplyOp extends MessageOp {\n  execute(node, tickNumber) {\n    console.log(\"Got ping back!\");\n    node.replyReceived();\n  }\n}\n\nexport default PingReplyOp;\n","import MessageOp from '../MessageOp';\nimport PingReplyOp from './PingReplyOp'\n\n/*\nOperation set in a node queue when a ping arrives.\nLogs and sends a reply.\n*/\nclass IncomingPingOp extends MessageOp {\n  execute(node, tickNumber) {\n    console.log(\"Got a ping request, sending back a reply\");\n    node.messageBroker.sendMessage(new PingReplyOp(this.from, node.name));\n  }\n}\n\nexport default IncomingPingOp;\n","/*\nBounded wait waits till tickToWait\nif waitConditionFn is true, the wait is cancelled\notherwise it is rescheduling itself\nif tickToWait passed and waitConditionFN still false, timeoutFn is called\n*/\nclass Timeout {\n  constructor(tickToWait, waitConditionFn, timeoutFn, label) {\n    this.tickToWait = tickToWait;\n    this.waitConditionFn = waitConditionFn;\n    this.timeoutFn = timeoutFn;\n    this.label = label;\n    this.op = this.constructor.name;\n  }\n\n  execute(node, tickNumber) {\n    if (this.waitConditionFn(node)) {\n      console.log(\"Condition met in \" + this.label);\n      return;\n    }\n    if (tickNumber < this.tickToWait) {\n      console.log(\"Still waiting\");\n      node.scheduleOp(this);\n      return;\n    }\n    // time out\n    console.log(\"Timed out: \" + this.label);\n    this.timeoutFn(node);\n  }\n}\n\nexport default Timeout;\n","import MessageOp from '../MessageOp';\nimport IncomingPingOp from './IncomingPingOp';\nimport Timeout from '../Timeout';\n\n/*\nThis operation actually sens a message to the other node.\n*/\nclass InitiatePingOp extends MessageOp {\n  execute(node, tickNumber) {\n    console.log(\"Executing \" + this.op + \" and sending ping to \" + this.to);\n    node.messageBroker.sendMessage(new IncomingPingOp(this.to, node.name));\n    const timeout = new Timeout(tickNumber + 10,\n      (node) => {return node.state.gotReply;},\n      (node) => {node.state.timedOut = true;},\n      \"Wait for reply\");\n    node.scheduleOp(timeout);\n  }\n}\n\nexport default InitiatePingOp;\n","import PingNode from './PingNode';\nimport InitiatePingOp from './InitiatePingOp';\n\n/*\nSimple request/reply example. A sends a message to B and waits 10 ticks\nfor a reply.\n*/\nclass Initializer {\n  create(messageBroker) {\n    const nodeA = new PingNode('A');\n    const nodeB = new PingNode('B');\n    nodeA.bind(messageBroker);\n    nodeB.bind(messageBroker);\n    nodeA.scheduleOp(new InitiatePingOp(\"B\"));\n  }\n\n  controlUI() {\n    return (\n      <div>\n        <h1>PING</h1>\n        <div>Open debug console to see log message. Keep clicking Tick for step-by-step progress.</div>\n        <div>To simulate a delay, use form below to add 12 ticks of sleep to B and keep ticking.</div>\n      </div>\n    );\n  }\n}\n\nexport default Initializer;\n","/*\nNon sendable operation, which sleeps for the given number of ticks.\nThis operation may simulate a node being busy. The node will still be\nable to receive messages, but win't process them.\n*/\nclass PauseOp {\n  constructor(sleep) {\n    this.sleep = sleep;\n  }\n\n  execute(node, tickNumber) {\n    if (this.sleep > 1) {\n      console.log(\"Still sleeping for \" + (this.sleep - 1));\n      node.scheduleOpOnTop(new PauseOp(this.sleep - 1));\n    } else {\n      console.log(\"Slept enough\");\n    }\n  }\n\n}\n\nexport default PauseOp;\n","import './App.css';\nimport MessageBroker from './MessageBroker';\n//import Initializer from './heartbeat/HeartBeatExample'\nimport Initializer from './ping/PingExample'\n//import Initializer from './basic-paxos/BasicPaxosExample'\n//import Initializer from './multi-paxos/MultiPaxosExample'\nimport React from 'react';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\nimport Button from '@material-ui/core/Button';\nimport TextField from '@material-ui/core/TextField';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport Select from '@material-ui/core/Select';\nimport PauseOp from './PauseOp';\n\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.messageBroker = new MessageBroker();\n    this.example = new Initializer();\n    this.example.create(this.messageBroker);\n    if (this.messageBroker.nodes.length === 0) {\n      throw new Error(\"No nodes to work with\");\n    }\n    this.state = {\n      nodes: [...this.messageBroker.nodes],\n      tick: 1,\n      brokenLinks: \"[]\",\n      sleepTicks: \"0\",\n      nodeToSleep: this.messageBroker.nodes[0].name\n    }\n    this.tick = this.tick.bind(this);\n    this.handleBrokenLinksChange = this.handleBrokenLinksChange.bind(this);\n    this.handleSleepTicksChange = this.handleSleepTicksChange.bind(this);\n    this.handleNodeToSleepChange = this.handleNodeToSleepChange.bind(this);\n    this.addSleepToNode = this.addSleepToNode.bind(this);\n  }\n\n  /*\n  The \"main\" method. On exec it goes over all nodes and executes one\n  operation from nodes' queues.\n  */\n  tick() {\n    if (!this.messageBroker.validateBrokenLinks()) {\n      return;\n    }\n    console.log(\"Start with tick \" + this.state.tick);\n    const scheduledTicks = [];\n    this.state.nodes.forEach(node => {\n      if (node.hasScheduledOps()) {\n        scheduledTicks.push(node);\n      }\n    });\n    scheduledTicks.forEach(node => {\n      console.log(\"Tick on \" + node.name);\n      node.tick(this.state.tick);\n    });\n    console.log(\"Done with tick \" + this.state.tick);\n    console.log(\"------------------------\");\n    const newTick = this.state.tick + 1;\n    const newNodes = [...this.messageBroker.nodes];\n    this.setState({\n      tick: newTick,\n      nodes: newNodes,\n    });\n  }\n\n  /*\n  Simulates a node being \"frozen\" for a bit.\n  */\n  addSleepToNode() {\n    this.state.nodes.forEach(node => {\n      if (node.name === this.state.nodeToSleep) {\n        console.log(\"Added sleep to \" + node.name);\n        node.scheduleOpOnTop(new PauseOp(parseInt(this.state.sleepTicks)));\n      }\n    });\n    this.setState({nodes: [...this.state.nodes]});\n  }\n\n  handleBrokenLinksChange(event) {\n    this.messageBroker.setBrokenLinks(event.target.value);\n    this.setState({brokenLinks: event.target.value});\n  }\n\n  handleSleepTicksChange(event) {\n    this.setState({sleepTicks: event.target.value});\n  }\n\n  handleNodeToSleepChange(event) {\n    this.setState({nodeToSleep: event.target.value});\n  }\n\n  render() {\n    return (\n      <div>\n        {this.example.controlUI()}\n        <Button variant=\"contained\" onClick={this.tick}>Tick ({this.state.tick})</Button><br/>\n        <TableContainer>\n          <Table aria-label=\"simple table\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Node name</TableCell>\n                <TableCell>Incoming queue</TableCell>\n                <TableCell>State</TableCell>\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {this.state.nodes.map((node) => (\n                <TableRow key={node.name}>\n                  <TableCell>\n                    {node.name}\n                  </TableCell>\n                  <TableCell>\n                    {node.queue.map((item, ind) => (<div key={node.name + item.op + ind}>{JSON.stringify(item)}</div>))}\n                  </TableCell>\n                  <TableCell>\n                  {Object.entries(node.state).map(([k,v]) => (\n                    <div key={node.name + k}><pre>{k}: {JSON.stringify(v, null, 2)}</pre></div>\n                  ))}\n                  </TableCell>\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <TextField\n        label='Json list of pairs of broken list. E.g. [[\"A\", \"B\"], [\"A\", \"C\"]] messages b/n A<->B and A<->C will be dropped.'\n        value={this.state.brokenLinks}\n        onChange={this.handleBrokenLinksChange}\n        multiline={true}\n        fullWidth={true}\n        rows=\"10\" /><br/>\n        <TextField\n        label='Sleep length in ticks'\n        value={this.state.sleepTicks}\n        onChange={this.handleSleepTicksChange}\n        multiline={false}\n        fullWidth={false}\n        rows=\"1\" />\n        <Select value={this.state.nodeToSleep} onChange={this.handleNodeToSleepChange}>\n          {this.state.nodes.map(node => (\n            <MenuItem key={node.name} value={node.name}>{node.name}</MenuItem>\n          ))}\n        </Select>\n        <Button variant=\"contained\" onClick={this.addSleepToNode}>Add sleep to {this.state.nodeToSleep}</Button><br/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}